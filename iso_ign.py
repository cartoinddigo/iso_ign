# -*- coding: utf-8 -*-
"""
/***************************************************************************
 IsoIGN
                                 A QGIS plugin
 Extraction de zone de chalandises et calcul d'itinéraires depuis l'API itineraire.ign.fr
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-11-20
        git sha              : $Format:%H$
        copyright            : (C) 2022 by T.Jacquemot
        email                : t.jacquemot@inddigo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from pathlib import Path
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from . import rss_ign


from qgis.core import QgsProject, QgsVectorLayer, QgsFeature, QgsGeometry, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsField, QgsPoint, QgsWkbTypes, QgsPointXY


# Import the code for the dialog
from .iso_ign_dialog import IsoIGNDialog
import os.path
import json, traceback

from PyQt5.Qt import QMessageBox

# from pickle import TRUE

try:
    import requests
except ModuleNotFoundError:
    print("installing requests")
    if platform.system() == "Windows":
        subprocess.call([sys.exec_prefix + "/python", "-m", "pip", "install", "requests"])
    else:
        subprocess.call(["python3", "-m", "pip", "install", "requests"])
    import requests

    try:
        import requests

        print("installation completed")
    except ModuleNotFoundError:
        QMessageBox.information(None, "ERROR", "Oops ! L'installation du module requests à échouée. Désolé de ne pas pouvoir aller plus loin...")

headers = {"User-Agent": "*"}
headers_v1 = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:100.0) Gecko/20100101 Firefox/100.0"}

URL = "https://itineraire.ign.fr/simple/1.0.0/"
IGN_KEY = 'jhyvi0fgmnuxvfv0zjzorvdn'

version = "3.4"


class IsoIGN:
    """Un Plugin QGIS pour calculer des aires de chalandises et recjercher des itinéraires à l'aide
    du Géoportail de l'IGN."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface and Project Instance
        self.iface = iface
        self.project = QgsProject.instance()

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(self.plugin_dir, "i18n", "IsoIGN_{}.qm".format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u"&IsoIGN")

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("IsoIGN", message)

    def add_action(self, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True, status_tip=None, whats_this=None, parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = Path(__file__).parent / "icon.png"
        self.add_action(str(icon_path), text=self.tr(u"IsoIGN"), callback=self.run, parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u"&IsoIGN"), action)
            self.iface.removeToolBarIcon(action)

    ########################################################################
    #                         Fonctions utiles                             #
    ########################################################################

    def get_bornes(self):
        self.u_bornes = self.iso_ign_windows.lineEdit_user_rq.text()

        self.u_bornes = self.u_bornes.replace(" ", "")
        if len(self.u_bornes) > 0:
            self.bornes = self.u_bornes.split(",")

            try:
                self.bornes = [int(i) if self.unit != "minutes" else int(i) * 60 for i in self.bornes]
            except ValueError:
                QMessageBox.warning(self.iso_ign_windows, "Oops !", "Les bornes doivent s'exprimer en chiffres")
                self.bornes = []
                return self.bornes

            return self.bornes
        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Liste de bornes vide !")

    def get_param(self):

        if self.iso_ign_windows.radioButton_voiture.isChecked():
            self.reseau = "profile=car"
        elif self.iso_ign_windows.radioButton_pieton.isChecked():
            self.reseau = "profile=pedestrian"
        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Veuillez choisir un type de réseau")

        if self.iso_ign_windows.radioButton_distance.isChecked():
            self.methode = "costType=distance&distanceUnit=meter"
            self.unit = "meter"
        elif self.iso_ign_windows.radioButton_temps.isChecked():
            self.methode = "costType=time&timeUnit=minute"
            self.unit = "minute"
        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Veuillez choisir une méthode de calcul")

    def ask_ign_v1(self, url):
        """fonction qui interroge le géoportail et qui retourne la réponse"""
        # print(url)
        # TODO : tester la connexion
        self.resp = requests.get(url, headers=headers_v1)
        print(headers_v1)
        print(self.resp)
        self.iso_output = self.resp.json()

        if self.iso_output:

            return self.iso_output

        else:
            return "bug"

    def ask_ign(self, url):
        """fonction qui interroge le géoportail et qui retourne la réponse"""
        # print(url)
        # TODO : tester la connexion
        self.resp = requests.get(url, headers=headers)
        self.iso_output = self.resp.json()

        if self.iso_output:

            return self.iso_output

        else:
            return "bug"

    ########################################################################
    #                         Mode Chalandises                             #
    ########################################################################

    def get_iso_v1(self):
        # Initialisation du compteur de réussite
        nb_ok = 0

        # Initialisation de la liste d'erreures
        lst_bug = []

        # Initialisation des paramètres de recherche
        """
        Paramètres de l'API v1:
        https://wxs.ign.fr/jhyvi0fgmnuxvfv0zjzorvdn/isochrone/isochrone.json?
        graphName=Voiture&
        method=distance&
        location=-1.583250,43.453710&
        reverse=false&
        exclusions=&
        srs=EPSG:4326&
        smoothing=true&
        holes=true&
        distance=100
        """
        urla = 'https://wxs.ign.fr/'
        urlb = '/isochrone/isochrone.json?location='
        urlc = '&smoothing=true&holes=false&reverse=true&'
        urle = '&srs=EPSG:4326'
        if self.reseau == "profile=car":
            graph = "Voiture"
        else:
            graph = "Pieton"
        
        if self.methode == "costType=distance&distanceUnit=meter":
            methode = 'method=distance&distance='
        else:
            methode = 'method=time&time='

        # test de présence de bornes
        try:
            rq_bornes = self.get_bornes()
        except Exception:
            self.iso_ign_windows.consol.setText(traceback.format_exc())
        if not rq_bornes:
            return

        # test si au moins un point origine est selectioné et reprojection en WGS84
        ori_layer = self.iface.activeLayer()
        selected_pt = ori_layer.selectedFeatures()

        if selected_pt:
            crsOri = ori_layer.crs()
            crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
            xform = QgsCoordinateTransform(crsOri, crsDest, self.project)
            for pt in selected_pt:
                ptt = pt.geometry()
                if ptt.type() == QgsWkbTypes.PointGeometry:
                    ptt.transform(xform)
                    pt.setGeometry(ptt)
                else:
                    QMessageBox.warning(self.iso_ign_windows, "Oops !", "Vous ne pouvez selectionner que des géométrie de type 'Point'")
                    return
        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Aucun point selectioné!")
            return

        # création du layer de résultats
        res_ly = QgsVectorLayer("Polygon", "Aire de chalandise", "memory")
        res_provider = res_ly.dataProvider()
        res_provider.addAttributes(ori_layer.fields())
        res_provider.addAttributes([QgsField("iso_cost", QVariant.Int)])
        res_provider.addAttributes([QgsField("iso_unit", QVariant.String)])
        res_ly.updateFields()

        # création du layer d'erreures
        err_ly = QgsVectorLayer("Point", "Erreures Aire de chalandise", "memory")
        err_provider = err_ly.dataProvider()
        err_provider.addAttributes(ori_layer.fields())
        err_provider.addAttributes([QgsField("iso_cost", QVariant.Int)])
        err_provider.addAttributes([QgsField("error", QVariant.String)])
        err_ly.updateFields()

        # Création de la liste de requêtes à effectuer
        lst_req = []
        for borne in rq_bornes:
            costValue = str(borne)
            for f in selected_pt:
                geom = f.geometry()
                gx = geom.asPoint().x()
                gy = geom.asPoint().y()
                coord = "%f,%f" % (gx, gy)
                feat_attribute = f.attributes()
                lst_req.append((coord, costValue, feat_attribute))
        
        # Effectue les recherche
        for r in lst_req:
            urlq = urla + IGN_KEY + urlb + r[0] + urlc + methode + r[1] + '&graphName=' + graph + urle
            print(urlq)
            res = self.ask_ign_v1(urlq)

            print(res)


    def get_iso_v2(self):
        # Initialisation du compteur de réussite
        nb_ok = 0

        # Initialisation de la liste d'erreures
        lst_bug = []

        # Initialisation des paramètres de recherche
        resource = "resource=bdtopo-pgr"
        costType = self.methode
        profile = self.reseau

        # test de présence de bornes
        try:
            rq_bornes = self.get_bornes()
        except Exception:
            self.iso_ign_windows.consol.setText(traceback.format_exc())
        if not rq_bornes:
            return

        # test si au moins un point origine est selectioné et reprojection en WGS84
        ori_layer = self.iface.activeLayer()
        selected_pt = ori_layer.selectedFeatures()

        if selected_pt:
            crsOri = ori_layer.crs()
            crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
            xform = QgsCoordinateTransform(crsOri, crsDest, self.project)
            for pt in selected_pt:
                ptt = pt.geometry()
                if ptt.type() == QgsWkbTypes.PointGeometry:
                    ptt.transform(xform)
                    pt.setGeometry(ptt)
                else:
                    QMessageBox.warning(self.iso_ign_windows, "Oops !", "Vous ne pouvez selectionner que des géométrie de type 'Point'")
                    return
        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Aucun point selectioné!")
            return

        # création du layer de résultats
        res_ly = QgsVectorLayer("Polygon", "Aire de chalandise", "memory")
        res_provider = res_ly.dataProvider()
        res_provider.addAttributes(ori_layer.fields())
        res_provider.addAttributes([QgsField("iso_cost", QVariant.Int)])
        res_provider.addAttributes([QgsField("iso_unit", QVariant.String)])
        res_ly.updateFields()

        # création du layer d'erreures
        err_ly = QgsVectorLayer("Point", "Erreures Aire de chalandise", "memory")
        err_provider = err_ly.dataProvider()
        err_provider.addAttributes(ori_layer.fields())
        err_provider.addAttributes([QgsField("iso_cost", QVariant.Int)])
        err_provider.addAttributes([QgsField("error", QVariant.String)])
        err_ly.updateFields()

        # Création de la liste de requêtes à effectuer
        lst_req = []
        for borne in rq_bornes:
            costValue = str(borne)
            for f in selected_pt:
                geom = f.geometry()
                gx = geom.asPoint().x()
                gy = geom.asPoint().y()
                coord = "%f,%f" % (gx, gy)
                feat_attribute = f.attributes()
                lst_req.append((coord, costValue, feat_attribute))

        # Effectue les recherche
        for r in lst_req:
            urlq = URL + "isochrone?" + resource + "&" + profile + "&" + costType + "&costValue=" + r[1] + "&point=" + r[0] + "&geometryFormat=geojson"

            res = self.ask_ign(urlq)
            if res == "bug":
                lst_bug.append((r[0], r[1], "pas de réponse de l'API", r[2]))
            elif "error" in res:
                lst_bug.append((r[0], r[1], res["error"]["message"], r[2]))
            elif res["geometry"]["type"] not in ["Polygon"]:
                lst_bug.append((r[0], r[1], "La réponse n'est pas un polygone", r[2]))
            else:
                res_feat = QgsFeature()

                for poly in res["geometry"]["coordinates"]:
                    val = ""
                    for pt in poly:
                        bi = "%f %f, " % (pt[0], pt[1])
                        val += bi
                    wkt = res["geometry"]["type"] + " " + "((" + val + "))"
                res_feat_geom = QgsGeometry.fromWkt(wkt)
                res_feat.setGeometry(res_feat_geom)
                data = r[2]
                data.append(r[1])
                data.append(self.unit)
                res_feat.setAttributes(data)
                res_provider.addFeature(res_feat)
                nb_ok += 1


        # Test et affiche les résults
        if res_ly.featureCount() > 0:
            self.project.addMapLayer(res_ly)
            res_ly.updateExtents()
            self.iface.layerTreeView().refreshLayerSymbology(res_ly.id())
            self.iso_ign_windows.consol.setText("{} aires de chalandises trouvée(s) et {} ont échouée(s)".format(nb_ok, len(lst_bug)))
        else:
            self.iso_ign_windows.consol.setText("Aucune aire de chalandise trouvée. Liste des erreures : " + str(lst_bug))
        
        # Affichage de la couche des erreures
        if len(lst_bug) > 0:

            for e in lst_bug:
                e[0].replace("'", '')
                x, y = e[0].split(",")
                x = float(x)
                y = float(y)
                err_pt = QgsFeature()
                err_data = e[3]
                err_data.append(e[1])
                err_data.append(e[2])
                err_pt.setAttributes(err_data) 
                err_pt.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(x, y)))
                err_provider.addFeatures([err_pt])
                
            self.project.addMapLayer(err_ly)

        
        

    ########################################################################
    #                         Mode Itinéraires                             #
    ########################################################################
    
    def get_iti(self):
        # Initialisation du compteur de réussite
        nb_ok = 0


        # Initialisation de la liste d'erreures
        lst_bug = []

        # Initialisation des paramètres de recherche
        resource = "resource=bdtopo-pgr"
        costType = self.methode
        profile = self.reseau

        # Initialisation des couches et champs origine et destination
        iti_ly_ori = self.iso_ign_windows.orily_picker.currentLayer()
        iti_f_ori = self.iso_ign_windows.orifield_picker.currentField()
        iti_ly_dest = self.iso_ign_windows.destly_picker.currentLayer()
        iti_f_dest = self.iso_ign_windows.destfield_picker.currentField()

        # Initialisation de la couche de résultats
        res_ly = QgsVectorLayer("Linestring", "itinéraire", "memory")
        res_provider = res_ly.dataProvider()

        # Ajout des champs identifiants à la couche des resultats
        res_provider.addAttributes([field for field in iti_ly_ori.fields() if field.name() in [iti_f_ori]])
        res_ly.updateFields()
        res_ly.startEditing()
        idx_to_change = res_ly.fields().names().index(iti_f_ori)
        res_ly.renameAttribute(idx_to_change, "id_ori")
        res_ly.commitChanges()

        res_provider.addAttributes([field for field in iti_ly_dest.fields() if field.name() in [iti_f_dest]])
        res_ly.updateFields()
        res_ly.startEditing()
        idx_to_change = res_ly.fields().names().index(iti_f_dest)
        res_ly.renameAttribute(idx_to_change, "id_dest")
        res_ly.commitChanges()

        res_provider.addAttributes([QgsField("profile", QVariant.String)])
        res_provider.addAttributes([QgsField("metres", QVariant.Int)])
        res_provider.addAttributes([QgsField("minutes", QVariant.Int)])
        res_ly.updateFields()

        # création d'une liste les coord des origines et l'identifiant :
        selected_ori_pt = iti_ly_ori.selectedFeatures()
        lst_coord_start = []
        if selected_ori_pt:

            crsOri = iti_ly_ori.crs()
            crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
            xform = QgsCoordinateTransform(crsOri, crsDest, self.project)
            for pt in selected_ori_pt:

                id_origine = pt[iti_f_ori]
                ptt = pt.geometry()
                ptt.transform(xform)
                pt.setGeometry(ptt)

                geom = pt.geometry()
                gx = geom.asPoint().x()
                gy = geom.asPoint().y()
                coord_start = "%f,%f" % (gx, gy)
                tpl_coord_strat = (id_origine, coord_start)
                lst_coord_start.append(tpl_coord_strat)

        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Aucune origine selectionée!")
            return

        # création d'une liste les coord des destinations:
        selected_dest_pt = iti_ly_dest.selectedFeatures()
        lst_coord_end = []
        if selected_dest_pt:

            crsOri = iti_ly_dest.crs()
            crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
            xform = QgsCoordinateTransform(crsOri, crsDest, self.project)

            for pt in selected_dest_pt:
                id_destination = pt[iti_f_dest]
                ptt = pt.geometry()
                ptt.transform(xform)
                pt.setGeometry(ptt)

                geom = pt.geometry()
                gx = geom.asPoint().x()
                gy = geom.asPoint().y()
                coord_end = "%f,%f" % (gx, gy)
                tpl_coord_end = (id_destination, coord_end)
                lst_coord_end.append(tpl_coord_end)

        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Aucune destination selectionée!")
            return

        # Test la méthode de calcul et création de la liste de requêtes
        methode_iti = self.iso_ign_windows.calciti_picker.currentIndex()


        # Mode Tous vers Tous
        ###############################################################

        if methode_iti == 0:
            # Méthode Tous vers Tous
            lst_od = []
            for o in lst_coord_start:
                for d in lst_coord_end:
                    idx_ori = "{}".format(o[0])
                    idx_dest = "{}".format(d[0])
                    req_od = "&start={}&end={}".format(o[1], d[1])
                    req_tpl = (idx_ori, idx_dest, req_od)
                    lst_od.append(req_tpl)
                    #print(lst_od)


        # Mode Un vers Un
        ###############################################################

        elif methode_iti == 1:
            # Méthode Un à Un
            # Test si le nombre de points est égale entre les origine et les destination
            if len(lst_coord_start) == len(lst_coord_end):
                tmp_lst_ori = []
                for o in lst_coord_start:
                    idx_ori = "{}".format(o[0])
                    coord_ori = "&start={}".format(o[1])
                    tmp_lst_ori.append((idx_ori, coord_ori))

                tmp_lst_dest = []
                for d in lst_coord_end:
                    idx_dest = "{}".format(d[0])
                    coord_dest = "&end={}".format(d[1])
                    tmp_lst_dest.append((idx_dest, coord_dest))

                lst_od = [(tmp_lst_ori[i][0], tmp_lst_dest[i][0], tmp_lst_ori[i][1] + tmp_lst_dest[i][1]) for i in range(0, len(tmp_lst_ori))]

                # tmplst = list(map(lambda x, y: (x, y), lst_coord_start, lst_coord_end))

            else:
                QMessageBox.warning(self.iso_ign_windows, "Oops !", "Le nombre de points de départ et d'arrivée doit être identique.")
                return


        # Mode Le plus proche
        ###############################################################

        else:
            # Méthode Le plus proche
            # TODO
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Comming soon !")
            return

        # Effectue les requêtes
        for od in lst_od:
            urlq = URL + "route?" + resource + "&" + profile + "&" + costType + od[2] + "&geometryFormat=geojson"
            res = self.ask_ign(urlq)
            if res == "bug":
                lst_bug.append("({}, {}, {})".format(od[0], od[1], "pas de réponse de l'API"))
            elif "error" in res:
                lst_bug.append("({}, {}, {})".format(od[0], od[1], res["error"]["message"]))
            elif res["geometry"]["type"] not in ["LineString"]:
                lst_bug.append("({}, {}, {})".format(od[0], od[1], "Le réponse n'est pas une polyigne"))
            else:

                val = ""
                for pt in res["geometry"]["coordinates"]:
                    bi = "%f %f, " % (pt[0], pt[1])
                    val += bi
                wkt = res["geometry"]["type"] + " " + "((" + val + "))"

                # Ajout des resultats dans le layer de resultats
                res_feat = QgsFeature()
                res_feat.setAttributes([od[0], od[1], res["profile"], res["distance"], res["duration"]])
                res_feat_geom = QgsGeometry.fromWkt(wkt)
                res_feat.setGeometry(res_feat_geom)
                res_provider.addFeature(res_feat)
                nb_ok += 1

        if res_ly.featureCount() > 0:
            self.project.addMapLayer(res_ly)
            res_ly.updateExtents()
            self.iface.layerTreeView().refreshLayerSymbology(res_ly.id())
            self.iso_ign_windows.consol.setText("{} itinéraires trouvé(s) et {} ont échoué(s)".format(nb_ok, len(lst_bug)))
        else:
            self.iso_ign_windows.consol.setText("Aucun itinéraire trouvé. Liste des erreures : " + str(lst_bug))

    ########################################################################
    #                         Perform alg                                  #
    ########################################################################

    def perform_rq_v2(self):
        # Test des services IGN (désactivé pour le dev)
        # testIgnSrv = str(rss_ign.ressourceIgn.resultats(rss_ign.ressourceIgn))
        testIgnSrv = "Tous les services de l'IGN fonctionnent"
        if testIgnSrv == "Tous les services de l'IGN fonctionnent":
	        # charge les paramètres de l'utilisateur
            try:
                self.get_param()
            except Exception:
                self.iso_ign_windows.consol.setText(traceback.format_exc())
            # test de la fonction demandée
            if self.iso_ign_windows.tabWidget.currentWidget().objectName() == "tab_iso":
                # recherche d'isochrones
                if self.iso_ign_windows.cb_choix_api.currentText() == "IGN v2":
                    #print("recherche d'aires de chalandises")
                    self.get_iso_v2()
                else:
                    self.get_iso_v1()
                    
            elif self.iso_ign_windows.tabWidget.currentWidget().objectName() == "tab_iti":
                # recherche d'itinéraires
                #print("Recherche d'itinéraires")
                self.get_iti()
            else:
                print("Pas de widget de recherche")
            return
        else:
            self.iso_ign_windows.consol.setText(testIgnSrv)
            return

    def run(self):
        """Affiche la gui et paramétrages par défaut"""

        self.iso_ign_windows = IsoIGNDialog()
        self.iso_ign_windows.radioButton_pieton.setChecked(True)
        self.iso_ign_windows.radioButton_distance.setChecked(True)
        #testIgnSrv = "Etats des serveurs de l'IGN : \n"+str(rss_ign.ressourceIgn.resultats(rss_ign.ressourceIgn))
        welkom_msg = "Bienvenue dans IsoIGN v" + version + ".\nQue voulez vous faire ?"
        self.iso_ign_windows.consol.setText(welkom_msg)
        self.iso_ign_windows.bt_ok.clicked.connect(self.perform_rq_v2)
        self.iso_ign_windows.show()
        