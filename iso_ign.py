# -*- coding: utf-8 -*-
"""
/***************************************************************************
 IsoIGN
                                 A QGIS plugin
 Extraction de zone de chalandises et calcul d'itinéraires depuis l'API itineraire.ign.fr
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-11-20
        git sha              : $Format:%H$
        copyright            : (C) 2022 by T.Jacquemot
        email                : t.jacquemot@inddigo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from pathlib import Path
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

from qgis.core import QgsProject, QgsVectorLayer, QgsFeature, QgsGeometry, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsField, QgsPoint, QgsWkbTypes, QgsPointXY


# Import the code for the dialog
from .iso_ign_dialog import IsoIGNDialog
import os.path
import json, traceback

from PyQt5.Qt import QMessageBox

# from pickle import TRUE

try:
    import requests
except ModuleNotFoundError:
    print("installing requests")
    if platform.system() == "Windows":
        subprocess.call([sys.exec_prefix + "/python", "-m", "pip", "install", "requests"])
    else:
        subprocess.call(["python3", "-m", "pip", "install", "requests"])
    import requests

    try:
        import requests

        print("installation completed")
    except ModuleNotFoundError:
        QMessageBox.information(None, "ERROR", "Oops ! L'installation du module requests à échouée. Désolé de ne pas pouvoir aller plus loin...")

headers = {"User-Agent": "*"}

URL = "https://itineraire.ign.fr/simple/1.0.0/"

version = "3.4"


class IsoIGN:
    """Un Plugin QGIS pour calculer des aires de chalandises et recjercher des itinéraires à l'aide
    du Géoportail de l'IGN."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface and Project Instance
        self.iface = iface
        self.project = QgsProject.instance()

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(self.plugin_dir, "i18n", "IsoIGN_{}.qm".format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u"&IsoIGN")

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("IsoIGN", message)

    def add_action(self, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True, status_tip=None, whats_this=None, parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = Path(__file__).parent / "icon.png"
        self.add_action(str(icon_path), text=self.tr(u"IsoIGN"), callback=self.run, parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u"&IsoIGN"), action)
            self.iface.removeToolBarIcon(action)

    ########################################################################
    #                         Fonctions utiles                             #
    ########################################################################

    def get_bornes(self):
        self.u_bornes = self.iso_ign_windows.lineEdit_user_rq.text()

        self.u_bornes = self.u_bornes.replace(" ", "")
        if len(self.u_bornes) > 0:
            self.bornes = self.u_bornes.split(",")

            try:
                self.bornes = [int(i) if self.unit != "minutes" else int(i) * 60 for i in self.bornes]
            except ValueError:
                QMessageBox.warning(self.iso_ign_windows, "Oops !", "Les bornes doivent s'exprimer en chiffres")
                self.bornes = []
                return self.bornes

            return self.bornes
        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Liste de bornes vide !")

    def get_param(self):

        if self.iso_ign_windows.radioButton_voiture.isChecked():
            self.reseau = "profile=car"
        elif self.iso_ign_windows.radioButton_pieton.isChecked():
            self.reseau = "profile=pedestrian"
        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Veuillez choisir un type de réseau")

        if self.iso_ign_windows.radioButton_distance.isChecked():
            self.methode = "costType=distance&distanceUnit=meter"
            self.unit = "meter"
        elif self.iso_ign_windows.radioButton_temps.isChecked():
            self.methode = "costType=time&timeUnit=minute"
            self.unit = "minute"
        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Veuillez choisir une méthode de calcul")

    def ask_ign(self, url):
        """fonction qui interroge le géoportail et qui retourne la réponse"""
        # print(url)
        # TODO : tester la connexion
        self.resp = requests.get(url, headers=headers)
        self.iso_output = self.resp.json()

        if self.iso_output:

            return self.iso_output

        else:
            return "bug"

    ########################################################################
    #                         Mode Chalandises                             #
    ########################################################################

    def get_iso(self):
        # Initialisation du compteur de réussite
        nb_ok = 0

        # Initialisation de la liste d'erreures
        lst_bug = []

        # Initialisation des paramètres de recherche
        resource = "resource=bdtopo-pgr"
        costType = self.methode
        profile = self.reseau

        # test de présence de bornes
        try:
            rq_bornes = self.get_bornes()
        except Exception:
            self.iso_ign_windows.consol.setText(traceback.format_exc())
        if not rq_bornes:
            return

        # test si au moins un point origine est selectioné et reprojection en WGS84
        ori_layer = self.iface.activeLayer()
        selected_pt = ori_layer.selectedFeatures()

        if selected_pt:
            crsOri = ori_layer.crs()
            crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
            xform = QgsCoordinateTransform(crsOri, crsDest, self.project)
            for pt in selected_pt:
                ptt = pt.geometry()
                if ptt.type() == QgsWkbTypes.PointGeometry:
                    ptt.transform(xform)
                    pt.setGeometry(ptt)
                else:
                    QMessageBox.warning(self.iso_ign_windows, "Oops !", "Vous ne pouvez selectionner que des géométrie de type 'Point'")
                    return
        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Aucun point selectioné!")
            return

        # création du layer de résultats
        res_ly = QgsVectorLayer("Polygon", "Aire de chalandise", "memory")
        res_provider = res_ly.dataProvider()
        res_provider.addAttributes(ori_layer.fields())
        res_provider.addAttributes([QgsField("iso_cost", QVariant.Int)])
        res_provider.addAttributes([QgsField("iso_unit", QVariant.String)])
        res_ly.updateFields()

        # création du layer d'erreures
        err_ly = QgsVectorLayer("Point", "Erreures Aire de chalandise", "memory")
        err_provider = err_ly.dataProvider()
        err_provider.addAttributes(ori_layer.fields())
        err_provider.addAttributes([QgsField("iso_cost", QVariant.Int)])
        err_provider.addAttributes([QgsField("error", QVariant.String)])
        err_ly.updateFields()

        # Création de la liste de requêtes à effectuer
        lst_req = []
        for borne in rq_bornes:
            costValue = str(borne)
            for f in selected_pt:
                geom = f.geometry()
                gx = geom.asPoint().x()
                gy = geom.asPoint().y()
                coord = "%f,%f" % (gx, gy)
                feat_attribute = f.attributes()
                lst_req.append((coord, costValue, feat_attribute))

        # Effectue les recherche
        for r in lst_req:
            urlq = URL + "isochrone?" + resource + "&" + profile + "&" + costType + "&costValue=" + r[1] + "&point=" + r[0] + "&geometryFormat=geojson"

            res = self.ask_ign(urlq)
            if res == "bug":
                lst_bug.append((r[0], r[1], "pas de réponse de l'API", r[2]))
            elif "error" in res:
                lst_bug.append((r[0], r[1], res["error"]["message"], r[2]))
            elif res["geometry"]["type"] not in ["Polygon"]:
                lst_bug.append((r[0], r[1], "La réponse n'est pas un polygone", r[2]))
            else:
                res_feat = QgsFeature()

                for poly in res["geometry"]["coordinates"]:
                    val = ""
                    for pt in poly:
                        bi = "%f %f, " % (pt[0], pt[1])
                        val += bi
                    wkt = res["geometry"]["type"] + " " + "((" + val + "))"
                res_feat_geom = QgsGeometry.fromWkt(wkt)
                res_feat.setGeometry(res_feat_geom)
                data = r[2]
                data.append(r[1])
                data.append(self.unit)
                res_feat.setAttributes(data)
                res_provider.addFeature(res_feat)
                nb_ok += 1

        # Test et affiche les résults
        if res_ly.featureCount() > 0:
            self.project.addMapLayer(res_ly)
            res_ly.updateExtents()
            self.iface.layerTreeView().refreshLayerSymbology(res_ly.id())
            self.iso_ign_windows.consol.setText("{} aires de chalandises trouvée(s) et {} ont échouée(s)".format(nb_ok, len(lst_bug)))
        else:
            self.iso_ign_windows.consol.setText("Aucune aire de chalandise trouvée. Liste des erreures : " + str(lst_bug))
        
        # Affichage de la couche des erreures
        for e in lst_bug:
            e[0].replace("'", '')
            x, y = e[0].split(",")
            x = float(x)
            y = float(y)
            err_pt = QgsFeature()
            err_data = e[3]
            err_data.append(e[1])
            err_data.append(e[2])
            err_pt.setAttributes(err_data) 
            err_pt.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(x, y)))
            err_provider.addFeatures([err_pt])
            
        self.project.addMapLayer(err_ly)

        
        

    ########################################################################
    #                         Mode Itinéraires                             #
    ########################################################################
    
    def get_iti(self):
        # Initialisation du compteur de réussite
        nb_ok = 0


        # Initialisation de la liste d'erreures
        lst_bug = []

        # Initialisation des paramètres de recherche
        resource = "resource=bdtopo-pgr"
        costType = self.methode
        profile = self.reseau

        # Initialisation des couches et champs origine et destination
        iti_ly_ori = self.iso_ign_windows.orily_picker.currentLayer()
        iti_f_ori = self.iso_ign_windows.orifield_picker.currentField()
        iti_ly_dest = self.iso_ign_windows.destly_picker.currentLayer()
        iti_f_dest = self.iso_ign_windows.destfield_picker.currentField()

        # Initialisation de la couche de résultats
        res_ly = QgsVectorLayer("Linestring", "itinéraire", "memory")
        res_provider = res_ly.dataProvider()

        # Ajout des champs identifiants à la couche des resultats
        res_provider.addAttributes([field for field in iti_ly_ori.fields() if field.name() in [iti_f_ori]])
        res_ly.updateFields()
        res_ly.startEditing()
        idx_to_change = res_ly.fields().names().index(iti_f_ori)
        res_ly.renameAttribute(idx_to_change, "id_ori")
        res_ly.commitChanges()

        res_provider.addAttributes([field for field in iti_ly_dest.fields() if field.name() in [iti_f_dest]])
        res_ly.updateFields()
        res_ly.startEditing()
        idx_to_change = res_ly.fields().names().index(iti_f_dest)
        res_ly.renameAttribute(idx_to_change, "id_dest")
        res_ly.commitChanges()

        res_provider.addAttributes([QgsField("profile", QVariant.String)])
        res_provider.addAttributes([QgsField("metres", QVariant.Int)])
        res_provider.addAttributes([QgsField("minutes", QVariant.Int)])
        res_ly.updateFields()

        # création d'une liste les coord des origines et l'identifiant :
        selected_ori_pt = iti_ly_ori.selectedFeatures()
        lst_coord_start = []
        if selected_ori_pt:

            crsOri = iti_ly_ori.crs()
            crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
            xform = QgsCoordinateTransform(crsOri, crsDest, self.project)
            for pt in selected_ori_pt:

                id_origine = pt[iti_f_ori]
                ptt = pt.geometry()
                ptt.transform(xform)
                pt.setGeometry(ptt)

                geom = pt.geometry()
                gx = geom.asPoint().x()
                gy = geom.asPoint().y()
                coord_start = "%f,%f" % (gx, gy)
                tpl_coord_strat = (id_origine, coord_start)
                lst_coord_start.append(tpl_coord_strat)

        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Aucune origine selectionée!")
            return

        # création d'une liste les coord des destinations:
        selected_dest_pt = iti_ly_dest.selectedFeatures()
        lst_coord_end = []
        if selected_dest_pt:

            crsOri = iti_ly_dest.crs()
            crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
            xform = QgsCoordinateTransform(crsOri, crsDest, self.project)

            for pt in selected_dest_pt:
                id_destination = pt[iti_f_dest]
                ptt = pt.geometry()
                ptt.transform(xform)
                pt.setGeometry(ptt)

                geom = pt.geometry()
                gx = geom.asPoint().x()
                gy = geom.asPoint().y()
                coord_end = "%f,%f" % (gx, gy)
                tpl_coord_end = (id_destination, coord_end)
                lst_coord_end.append(tpl_coord_end)

        else:
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Aucune destination selectionée!")
            return

        # Test la méthode de calcul et création de la liste de requêtes
        methode_iti = self.iso_ign_windows.calciti_picker.currentIndex()


        # Mode Tous vers Tous
        ###############################################################

        if methode_iti == 0:
            # Méthode Tous vers Tous
            lst_od = []
            for o in lst_coord_start:
                for d in lst_coord_end:
                    idx_ori = "{}".format(o[0])
                    idx_dest = "{}".format(d[0])
                    req_od = "&start={}&end={}".format(o[1], d[1])
                    req_tpl = (idx_ori, idx_dest, req_od)
                    lst_od.append(req_tpl)
                    #print(lst_od)


        # Mode Un vers Un
        ###############################################################

        elif methode_iti == 1:
            # Méthode Un à Un
            # Test si le nombre de points est égale entre les origine et les destination
            if len(lst_coord_start) == len(lst_coord_end):
                tmp_lst_ori = []
                for o in lst_coord_start:
                    idx_ori = "{}".format(o[0])
                    coord_ori = "&start={}".format(o[1])
                    tmp_lst_ori.append((idx_ori, coord_ori))

                tmp_lst_dest = []
                for d in lst_coord_end:
                    idx_dest = "{}".format(d[0])
                    coord_dest = "&end={}".format(d[1])
                    tmp_lst_dest.append((idx_dest, coord_dest))

                lst_od = [(tmp_lst_ori[i][0], tmp_lst_dest[i][0], tmp_lst_ori[i][1] + tmp_lst_dest[i][1]) for i in range(0, len(tmp_lst_ori))]

                # tmplst = list(map(lambda x, y: (x, y), lst_coord_start, lst_coord_end))

            else:
                QMessageBox.warning(self.iso_ign_windows, "Oops !", "Le nombre de points de départ et d'arrivée doit être identique.")
                return


        # Mode Le plus proche
        ###############################################################

        else:
            # Méthode Le plus proche
            # TODO
            QMessageBox.warning(self.iso_ign_windows, "Oops !", "Comming soon !")
            return

        # Effectue les requêtes
        for od in lst_od:
            urlq = URL + "route?" + resource + "&" + profile + "&" + costType + od[2] + "&geometryFormat=geojson"
            res = self.ask_ign(urlq)
            if res == "bug":
                lst_bug.append("({}, {}, {})".format(od[0], od[1], "pas de réponse de l'API"))
            elif "error" in res:
                lst_bug.append("({}, {}, {})".format(od[0], od[1], res["error"]["message"]))
            elif res["geometry"]["type"] not in ["LineString"]:
                lst_bug.append("({}, {}, {})".format(od[0], od[1], "Le réponse n'est pas une polyigne"))
            else:

                val = ""
                for pt in res["geometry"]["coordinates"]:
                    bi = "%f %f, " % (pt[0], pt[1])
                    val += bi
                wkt = res["geometry"]["type"] + " " + "((" + val + "))"

                # Ajout des resultats dans le layer de resultats
                res_feat = QgsFeature()
                res_feat.setAttributes([od[0], od[1], res["profile"], res["distance"], res["duration"]])
                res_feat_geom = QgsGeometry.fromWkt(wkt)
                res_feat.setGeometry(res_feat_geom)
                res_provider.addFeature(res_feat)
                nb_ok += 1

        if res_ly.featureCount() > 0:
            self.project.addMapLayer(res_ly)
            res_ly.updateExtents()
            self.iface.layerTreeView().refreshLayerSymbology(res_ly.id())
            self.iso_ign_windows.consol.setText("{} itinéraires trouvé(s) et {} ont échoué(s)".format(nb_ok, len(lst_bug)))
        else:
            self.iso_ign_windows.consol.setText("Aucun itinéraire trouvé. Liste des erreures : " + str(lst_bug))

    ########################################################################
    #                         Perform alg                                  #
    ########################################################################

    def perform_rq_v2(self):
        # charge les paramètres de l'utilisateur
        try:
            self.get_param()
        except Exception:
            self.iso_ign_windows.consol.setText(traceback.format_exc())
        # test de la fonction demandée
        if self.iso_ign_windows.tabWidget.currentWidget().objectName() == "tab_iso":
            # recherche d'isochrones
            #print("recherche d'aires de chalandises")
            self.get_iso()
        elif self.iso_ign_windows.tabWidget.currentWidget().objectName() == "tab_iti":
            # recherche d'itinéraires
            #print("Recherche d'itinéraires")
            self.get_iti()
        else:
            print("Pas de widget de recherche")
        return

    def run(self):
        """Affiche la gui et paramétrages par défaut"""

        self.iso_ign_windows = IsoIGNDialog()
        self.iso_ign_windows.radioButton_pieton.setChecked(True)
        self.iso_ign_windows.radioButton_distance.setChecked(True)
        welkom_msg = "Bienvenue dans IsoIGN v" + version + ". Que voulez vous faire ?"
        self.iso_ign_windows.consol.setText(welkom_msg)
        self.iso_ign_windows.bt_ok.clicked.connect(self.perform_rq_v2)
        self.iso_ign_windows.show()
